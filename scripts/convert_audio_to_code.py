import os
import wave
import struct

# INSTRUCTIONS:
# 1. create audio samples as signed 16 bit mono pcm encoded 48khz wav files
# 2. put them in {root_dir}/assets
# 3. may need to install the wave python package `pip install wave`
# 4. run this python file `python3 ./scripts/convert_audio_to_code.py`
# 5. all the code-gen will be in {root_dir}/Audible-Altimeter-Embedded/audio/samples

print("whoops sorry i ran this file and then changed a bunch of stuff")
print("by editing the files themselves, don't run again until i update")
print("so both header files are output")
exit(1)

py_file_abspath = os.path.abspath(__file__)

os.chdir(os.path.join(os.path.dirname(py_file_abspath), ".."))

AUDIO_FILE_DIRECTORY = os.path.join(os.getcwd(), "assets")
AUDIO_ARRAY_DIRECTORY = os.path.join(os.getcwd(), "Audible-Altimeter-Embedded", "audio", "samples")
header_file_name = "audio_samples"
generated_warning = f'''
////////////////////////////////////////////////////////////////////////////////
///////////////////// THIS FILE IS AUTOGENERATED ///////////////////////////////
///////////////////// DO NOT EDIT !!!!!!        ////////////////////////////////
///////////////////// created by {__file__} ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
'''

class SampleMetadata:
    full_path: str
    filename: str
    sample_name: str
    samples: list[int]
    num_samples: int

SAMPLE_RATE = 0

def get_samples(wav_file):
    global SAMPLE_RATE
    samples = []
    with wave.open(wav_file, 'rb') as wav:
        assert wav.getsampwidth() == 2, "WAV file is not 16-bit"
        assert wav.getframerate() == 48000, "WAV file is not 48000 Hz"
        assert wav.getnchannels() == 1, "WAV file is not mono"
        SAMPLE_RATE = wav.getnchannels()

        # Read frames and convert to 16-bit signed integers
        num_samples = wav.getnframes()
        frames = wav.readframes(num_samples)

        # Unpack the frames into a list of 16-bit signed integers
        samples = struct.unpack(f'<{num_samples}h', frames)
    return samples

def create_header_file(samples: list[SampleMetadata]):
    header_file_path = os.path.abspath(os.path.join(AUDIO_ARRAY_DIRECTORY, f'{header_file_name}.h'))
    header_file_contents = generated_warning
    header_file_contents += f'''
#ifndef _{header_file_name.upper()}_H
#define _{header_file_name.upper()}_H

#include <cstdint>
#include <array>\n
'''
    header_file_contents += f"constexpr std::size_t SAMPLE_RATE {{ {SAMPLE_RATE} }};\n"
    header_file_contents += 'namespace AUDIO_SAMPLE {\n '
    header_file_contents += 'constexpr std::size_t BEGIN_SAMPLES { 0 };\n '

    for i, sample in enumerate(samples):
        header_file_contents += f'constexpr std::size_t {sample.sample_name.upper()} {{ {i} }};\n'

    header_file_contents += f"constexpr std::size_t END_SAMPLES {{ {len(samples)} }};\n"
    header_file_contents += f"constexpr std::size_t NUM_SAMPLES {{ {len(samples)} }};\n"
    header_file_contents += '};\n'
    header_file_contents += '''
struct Audio_sample_location_and_size {
    std::int16_t* location;
    std::size_t size;
};\n
'''
    for sample in samples:
        header_file_contents += f'extern std::array<std::int16_t, {sample.num_samples}> {sample.sample_name};\n'

    header_file_contents += '''
    using sample_lookup_t = std::array<Audio_sample_location_and_size,
                            AUDIO_SAMPLE_ID::NUM_SAMPLES>;
constexpr sample_lookup_t sample_lookup = {
'''
    for sample in samples:
        header_file_contents += f'        Audio_sample_location_and_size{{ {sample.sample_name}.data(), {sample.sample_name}.size() }},\n'
    header_file_contents += "    };"

    header_file_contents += f'''
#endif // _{header_file_name.upper()}_H
'''
    with open(header_file_path, 'w') as f:
        f.write(header_file_contents)  # Write each sample name on a new line


def create_cpp_files(samples: list[SampleMetadata]):
    # for sample in samples:
    for sample in samples:
        cpp_file_path = os.path.abspath(os.path.join(AUDIO_ARRAY_DIRECTORY, f'{sample.sample_name}.cpp'))

        cpp_file_contents = generated_warning
        # Create the C++ array string
        cpp_file_contents += f'''#include "{header_file_name}.h"

#include <array>
#include <cstdint>\n
'''
        cpp_file_contents += f'std::array<std::int16_t, {sample.num_samples}> {sample.sample_name} = {{\n'
        cpp_file_contents += ',\n'.join(f'    {num}' for num in sample.samples)
        cpp_file_contents += '\n};'
        with open(cpp_file_path, 'w') as f:
            f.write(cpp_file_contents)  # Write each sample name on a new line
def create_cmake_file(samples: list[SampleMetadata]):
    cmake_file_path = os.path.abspath(os.path.join(AUDIO_ARRAY_DIRECTORY, 'CMakeLists.txt'))

    # Collect source file names
    cpp_files = [f'{sample.sample_name}.cpp' for sample in samples]

    cmake_file_contents = f'''# Auto-generated CMakeLists.txt for audio samples
set(SOURCES
    {header_file_name}.h
'''
    cmake_file_contents += ''.join(f'    {cpp_file}\n' for cpp_file in cpp_files)
    cmake_file_contents += ''')

# add_library(audio_samples STATIC ${SOURCE_FILES})

# Specify include directories
target_include_directories(audio_samples PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
'''
    with open(cmake_file_path, 'w') as f:
        f.write(cmake_file_contents)

def collect_wav_samples_files(directory):
    sample_list: list[SampleMetadata] = []

    wav_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".wav"):
                wav_files.append(os.path.abspath(os.path.join(root, file)))

    for wav in wav_files:
        data = SampleMetadata()
        data.full_path = wav
        data.sample_name = os.path.splitext(os.path.basename(wav))[0]
        data.samples = get_samples(wav)
        data.num_samples = len(data.samples)
        sample_list.append(data)

    return sample_list


def main():
    samples = collect_wav_samples_files(AUDIO_FILE_DIRECTORY)
    create_header_file(samples)
    create_cpp_files(samples)
    # create_cmake_file(samples)

if __name__ == '__main__':
    main()